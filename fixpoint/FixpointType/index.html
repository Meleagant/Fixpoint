<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>FixpointType (fixpoint.FixpointType)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">fixpoint</a> &#x00BB; FixpointType</nav><header class="odoc-preamble"><h1>Module <code><span>FixpointType</span></code></h1><p>Fixpoint analysis of an equation system: types</p></header><nav class="odoc-toc"><ul><li><a href="#public-datatypes">Public datatypes</a><ul><li><a href="#manager">Manager</a></li><li><a href="#dynamically-explored-equation-system">Dynamically explored equation system</a></li><li><a href="#iteration-strategies">Iteration strategies</a></li><li><a href="#output">Output</a></li></ul></li><li><a href="#internal-datatypes">Internal datatypes</a></li><li><a href="#dot-output">DOT output</a></li></ul></nav><div class="odoc-content"><h3 id="public-datatypes"><a href="#public-datatypes" class="anchor"></a>Public datatypes</h3><h4 id="manager"><a href="#manager" class="anchor"></a>Manager</h4><p>The manager parameterizes the fixpoint solver with the following types:</p><ul><li><code>'vertex</code>: type of vertex/variable (identifier) in the hypergraph describing the equation system;</li><li><code>'hedge</code>: type of hyperedge/function (identifier) in the hypergraph describing the equation system;</li><li><code>'abstract</code>: type of abstract values associated to vertices/variables;</li><li><code>'arc</code>: type of information associated to hyperedges/functions;</li></ul><p>and values:</p><ul><li>Lattice operations on abstract values; the argument of type <code>'vertex</code> indicates to which vertex the result of the function is associated (useful when abstract values are typed by an environment, for instance)</li><li>Functions to initialize variables and to interpret hyperedges/functions;</li><li>Printing functions for type parameters;</li><li>Options, mainly about widening;</li><li>Debugging options, for text (and possibly DOT) output on the formatter <code>print_fmt</code>;</li><li>Printing functions for DOT output on the optional formatter <code>dot_fmt</code>.</li></ul><div class="odoc-spec"><div class="spec type anchored" id="type-manager"><a href="#type-manager" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge, 'abstract, 'arc) manager</span></span><span> = </span><span>{</span></code><ol><li id="type-manager.bottom" class="def record field anchored"><a href="#type-manager.bottom" class="anchor"></a><code><span><span class="keyword">mutable</span> bottom : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Create a bottom value</p><span class="comment-delim">*)</span></div></li><li id="type-manager.canonical" class="def record field anchored"><a href="#type-manager.canonical" class="anchor"></a><code><span><span class="keyword">mutable</span> canonical : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Make an abstract value canonical</p><span class="comment-delim">*)</span></div></li><li id="type-manager.is_bottom" class="def record field anchored"><a href="#type-manager.is_bottom" class="anchor"></a><code><span><span class="keyword">mutable</span> is_bottom : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Emptiness test</p><span class="comment-delim">*)</span></div></li><li id="type-manager.is_leq" class="def record field anchored"><a href="#type-manager.is_leq" class="anchor"></a><code><span><span class="keyword">mutable</span> is_leq : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Inclusion test</p><span class="comment-delim">*)</span></div></li><li id="type-manager.join" class="def record field anchored"><a href="#type-manager.join" class="anchor"></a><code><span><span class="keyword">mutable</span> join : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code></li><li id="type-manager.join_list" class="def record field anchored"><a href="#type-manager.join_list" class="anchor"></a><code><span><span class="keyword">mutable</span> join_list : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'abstract</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binary and n-ary join operation</p><span class="comment-delim">*)</span></div></li><li id="type-manager.widening" class="def record field anchored"><a href="#type-manager.widening" class="anchor"></a><code><span><span class="keyword">mutable</span> widening : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Apply widening at the given point, with the two arguments. Widening will always be applied with first argument being included in the second one.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.odiff" class="def record field anchored"><a href="#type-manager.odiff" class="anchor"></a><code><span><span class="keyword">mutable</span> odiff : <span><span>(<span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>)</span> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Sound approximation of set difference (optional)</p><span class="comment-delim">*)</span></div></li><li id="type-manager.abstract_init" class="def record field anchored"><a href="#type-manager.abstract_init" class="anchor"></a><code><span><span class="keyword">mutable</span> abstract_init : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return the non-bottom initial value associated to the given vertex</p><span class="comment-delim">*)</span></div></li><li id="type-manager.arc_init" class="def record field anchored"><a href="#type-manager.arc_init" class="anchor"></a><code><span><span class="keyword">mutable</span> arc_init : <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'arc</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Initial value for arcs</p><span class="comment-delim">*)</span></div></li><li id="type-manager.apply" class="def record field anchored"><a href="#type-manager.apply" class="anchor"></a><code><span><span class="keyword">mutable</span> apply : <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'abstract</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'arc</span> * <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Apply the function indexed by <code>hedge</code> to the array of arguments.</p><p>It returns the new abstract value, but also a user-defined information that will be associated to the hyperedge in the result.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.print_vertex" class="def record field anchored"><a href="#type-manager.print_vertex" class="anchor"></a><code><span><span class="keyword">mutable</span> print_vertex : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-manager.print_hedge" class="def record field anchored"><a href="#type-manager.print_hedge" class="anchor"></a><code><span><span class="keyword">mutable</span> print_hedge : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-manager.print_abstract" class="def record field anchored"><a href="#type-manager.print_abstract" class="anchor"></a><code><span><span class="keyword">mutable</span> print_abstract : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-manager.print_arc" class="def record field anchored"><a href="#type-manager.print_arc" class="anchor"></a><code><span><span class="keyword">mutable</span> print_arc : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'arc</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Printing functions</p><span class="comment-delim">*)</span></div></li><li id="type-manager.accumulate" class="def record field anchored"><a href="#type-manager.accumulate" class="anchor"></a><code><span><span class="keyword">mutable</span> accumulate : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If true, during ascending phase, compute the union of old reachable value with growing incoming hyperedges. If false, recompute all incoming hyperedges.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.print_fmt" class="def record field anchored"><a href="#type-manager.print_fmt" class="anchor"></a><code><span><span class="keyword">mutable</span> print_fmt : <span class="xref-unresolved">Stdlib</span>.Format.formatter;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typically equal to <code>Format.std_formatter</code></p><span class="comment-delim">*)</span></div></li><li id="type-manager.print_analysis" class="def record field anchored"><a href="#type-manager.print_analysis" class="anchor"></a><code><span><span class="keyword">mutable</span> print_analysis : bool;</span></code></li><li id="type-manager.print_component" class="def record field anchored"><a href="#type-manager.print_component" class="anchor"></a><code><span><span class="keyword">mutable</span> print_component : bool;</span></code></li><li id="type-manager.print_step" class="def record field anchored"><a href="#type-manager.print_step" class="anchor"></a><code><span><span class="keyword">mutable</span> print_step : bool;</span></code></li><li id="type-manager.print_state" class="def record field anchored"><a href="#type-manager.print_state" class="anchor"></a><code><span><span class="keyword">mutable</span> print_state : bool;</span></code></li><li id="type-manager.print_postpre" class="def record field anchored"><a href="#type-manager.print_postpre" class="anchor"></a><code><span><span class="keyword">mutable</span> print_postpre : bool;</span></code></li><li id="type-manager.print_workingsets" class="def record field anchored"><a href="#type-manager.print_workingsets" class="anchor"></a><code><span><span class="keyword">mutable</span> print_workingsets : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Printing Options</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_fmt" class="def record field anchored"><a href="#type-manager.dot_fmt" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_fmt : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Some fmt</code> enables DOT output. You can set dummy values to the fields below if you always set <code>None</code> and you do not want DOT output.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_vertex" class="def record field anchored"><a href="#type-manager.dot_vertex" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_vertex : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print vertex identifiers in DOT format</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_hedge" class="def record field anchored"><a href="#type-manager.dot_hedge" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_hedge : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print hyperedge identifiers in DOT format (vertices and hyperedges identifiers should be different, as they are represented by DOT vertices</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_attrvertex" class="def record field anchored"><a href="#type-manager.dot_attrvertex" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_attrvertex : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print the displayed information in boxes</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_attrhedge" class="def record field anchored"><a href="#type-manager.dot_attrhedge" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_attrhedge : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print the displayed information for hyperedges</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><h4 id="dynamically-explored-equation-system"><a href="#dynamically-explored-equation-system" class="anchor"></a>Dynamically explored equation system</h4><div class="odoc-spec"><div class="spec type anchored" id="type-equation"><a href="#type-equation" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) equation</span></span><span> =
  <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'hedge</span>, <span><span class="type-var">'vertex</span> array</span> * <span class="type-var">'vertex</span>)</span> <span class="xref-unresolved">Camllib</span>.PMappe.t</span></span></code></div><div class="spec-doc"><p>Function that explores dynamically an equation system. <code>equation vertex</code> returns a map hat associates to each successor hyperedge a pair of composed of the set of predecessor vertices, and the successor vertex.</p></div></div><h4 id="iteration-strategies"><a href="#iteration-strategies" class="anchor"></a>Iteration strategies</h4><div class="odoc-spec"><div class="spec type anchored" id="type-strategy_iteration"><a href="#type-strategy_iteration" class="anchor"></a><code><span><span class="keyword">type</span> strategy_iteration</span><span> = </span><span>{</span></code><ol><li id="type-strategy_iteration.widening_start" class="def record field anchored"><a href="#type-strategy_iteration.widening_start" class="anchor"></a><code><span><span class="keyword">mutable</span> widening_start : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Nb of initial steps without widening in the current strategy</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.widening_descend" class="def record field anchored"><a href="#type-strategy_iteration.widening_descend" class="anchor"></a><code><span><span class="keyword">mutable</span> widening_descend : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Maximum nb. of descending steps in the current strategy</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.ascending_nb" class="def record field anchored"><a href="#type-strategy_iteration.ascending_nb" class="anchor"></a><code><span><span class="keyword">mutable</span> ascending_nb : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For stats</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.descending_nb" class="def record field anchored"><a href="#type-strategy_iteration.descending_nb" class="anchor"></a><code><span><span class="keyword">mutable</span> descending_nb : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For stats</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.descending_stable" class="def record field anchored"><a href="#type-strategy_iteration.descending_stable" class="anchor"></a><code><span><span class="keyword">mutable</span> descending_stable : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For stats</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Widening and Descending Options</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-strategy_vertex"><a href="#type-strategy_vertex" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) strategy_vertex</span></span><span> = </span><span>{</span></code><ol><li id="type-strategy_vertex.vertex" class="def record field anchored"><a href="#type-strategy_vertex.vertex" class="anchor"></a><code><span><span class="keyword">mutable</span> vertex : <span class="type-var">'vertex</span>;</span></code></li><li id="type-strategy_vertex.hedges" class="def record field anchored"><a href="#type-strategy_vertex.hedges" class="anchor"></a><code><span><span class="keyword">mutable</span> hedges : <span><span class="type-var">'hedge</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Order in which the incoming hyperedges will be applied</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_vertex.widen" class="def record field anchored"><a href="#type-strategy_vertex.widen" class="anchor"></a><code><span><span class="keyword">mutable</span> widen : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Should this vertex be a widening point ?</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Strategy to be applied for the vertex <code>vertex</code>.</p><ul><li><code>hedges</code> is a list of incoming hyperedges. The effect of hyperedges are applied &quot;in parallel&quot; and the destination vertex is updated. Be cautious: if an incoming hyperedge is forgotten in this list, it won't be taken into account in the analysis.</li></ul><ul><li><code>widen</code> specifies whether the vertex is a widening point or not.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-strategy"><a href="#type-strategy" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) strategy</span></span><span> =
  <span><span>(<a href="#type-strategy_iteration">strategy_iteration</a>, <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-strategy_vertex">strategy_vertex</a></span>)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span></span></code></div><div class="spec-doc"><p>Type for defining iteration strategies. For instance, <code>[1; [2;3]; 4;
      [5]; 6]</code> means:</p><ul><li>update <code>1</code>;</li><li>update <code>2</code> then <code>3</code>, and loop until stabilization;</li><li>update <code>4</code>;</li><li>update <code>5</code> and loop until stabilization;</li><li>update <code>6</code> and ends the analysis.</li></ul><p>Moreover, to each (imbricated) list is associated a record of type <code>strategy_iteration</code>, which indicates when to start the widening, and the maximum number of descending iterations.</p><p>Some observations on this example:</p><ul><li>The user should specify correctly the strategy. Two vertices belonging to the same connex component should always belong to a loop. Here, if there is an edge from <code>6</code> to <code>2</code>, the loop will not be iterated.</li><li>A vertex may appear more than once in the strategy, if it is useful.</li><li>Definition of the set of widening point is independent from the order</li><li>of application, here. it is alos the user-responsability to ensure that</li><li>the computation will end.</li></ul><p>So-called stabilization loops can be recursive, like that: <code>[1; [2;
        [3;4]; [5]]; 6]</code>, where the loop <code>[3;4]</code> needs to be (temporarily stable) before going on with <code>5</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_strategy_iteration"><a href="#val-print_strategy_iteration" class="anchor"></a><code><span><span class="keyword">val</span> print_strategy_iteration : 
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-strategy_iteration">strategy_iteration</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_strategy_vertex"><a href="#val-print_strategy_vertex" class="anchor"></a><code><span><span class="keyword">val</span> print_strategy_vertex : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-strategy_vertex">strategy_vertex</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>print_strategy_vertex man fmt sv</code> prints an object of type <code>strategy_vertex</code>, using the manager <code>man</code> for printing vertices and hyperedges. The output has the form <code>(boolean,vertex,[list of list of
          hedges])</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_strategy"><a href="#val-print_strategy" class="anchor"></a><code><span><span class="keyword">val</span> print_strategy : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-strategy">strategy</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>print_strategy_vertex man fmt sv</code> prints an object of type <code>strategy</code>, using the manager <code>man</code> for printing vertices and hyperedges.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_strategy_iteration"><a href="#val-make_strategy_iteration" class="anchor"></a><code><span><span class="keyword">val</span> make_strategy_iteration : 
  <span><span class="optlabel">?widening_start</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?widening_descend</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-strategy_iteration">strategy_iteration</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_strategy_default"><a href="#val-make_strategy_default" class="anchor"></a><code><span><span class="keyword">val</span> make_strategy_default : 
  <span><span class="optlabel">?depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?widening_start</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?widening_descend</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?priority</span>:<span><span class="type-var">'hedge</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.priority</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">vertex_dummy</span>:<span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">hedge_dummy</span>:<span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'vertex</span> <span class="xref-unresolved">Camllib</span>.PSette.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-strategy">strategy</a></span></span></code></div><div class="spec-doc"><p>Build a &quot;default&quot; strategy, with the following options:</p><ul><li>depth: to apply the recursive strategy of Bourdoncle's paper. Default value is 2, which means that Strongly Connected Components are stabilized independently: the iteration order looks like <code>(1 2 (3 4 5)
       6 (7 8) 9)</code> where <code>1, 2, 6, 9</code> are SCC by themselves. A higher value defines a more recursive behavior, like <code>(1 2 (3 (4 5)) 6 (7 (8)) 9)</code>.</li></ul><ul><li>iteration: for each strategy, nb if initial steps without widening and max nb. of descending steps (the latter being used only for depth 2). Default is <code>(0,1)</code>.</li></ul><ul><li>priority: specify which hedges should be taken into account in the computation of the iteration order and the widening points (the one such that <code>priority h &gt;= 0</code> and the widening points, and also indicates which hyperedge should be explored first at a point of choice.</li></ul><p>One known usage for filtering: guided analysis, where one analyse a subgraph of the equation graph.</p></div></div><h4 id="output"><a href="#output" class="anchor"></a>Output</h4><div class="odoc-spec"><div class="spec type anchored" id="type-stat_iteration"><a href="#type-stat_iteration" class="anchor"></a><code><span><span class="keyword">type</span> stat_iteration</span><span> = </span><span>{</span></code><ol><li id="type-stat_iteration.nb" class="def record field anchored"><a href="#type-stat_iteration.nb" class="anchor"></a><code><span><span class="keyword">mutable</span> nb : int;</span></code></li><li id="type-stat_iteration.stable" class="def record field anchored"><a href="#type-stat_iteration.stable" class="anchor"></a><code><span><span class="keyword">mutable</span> stable : bool;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stat"><a href="#type-stat" class="anchor"></a><code><span><span class="keyword">type</span> stat</span><span> = </span><span>{</span></code><ol><li id="type-stat.time" class="def record field anchored"><a href="#type-stat.time" class="anchor"></a><code><span><span class="keyword">mutable</span> time : float;</span></code></li><li id="type-stat.ascending" class="def record field anchored"><a href="#type-stat.ascending" class="anchor"></a><code><span><span class="keyword">mutable</span> ascending : <span><span>(<a href="#type-stat_iteration">stat_iteration</a>, unit)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span>;</span></code></li><li id="type-stat.descending" class="def record field anchored"><a href="#type-stat.descending" class="anchor"></a><code><span><span class="keyword">mutable</span> descending : <span><span>(<a href="#type-stat_iteration">stat_iteration</a>, unit)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-output"><a href="#type-output" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge, 'abstract, 'arc) output</span></span><span> =
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'abstract</span>, <span class="type-var">'arc</span>, <a href="#type-stat">stat</a>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span></span></code></div><div class="spec-doc"><p>result of the analysis</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ilist_map_condense"><a href="#val-ilist_map_condense" class="anchor"></a><code><span><span class="keyword">val</span> ilist_map_condense : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stat_iteration_merge"><a href="#val-stat_iteration_merge" class="anchor"></a><code><span><span class="keyword">val</span> stat_iteration_merge : 
  <span><span><span>(<a href="#type-stat_iteration">stat_iteration</a>, unit)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-stat_iteration">stat_iteration</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_stat_iteration"><a href="#val-print_stat_iteration" class="anchor"></a><code><span><span class="keyword">val</span> print_stat_iteration : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stat_iteration">stat_iteration</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_stat_iteration_ilist"><a href="#val-print_stat_iteration_ilist" class="anchor"></a><code><span><span class="keyword">val</span> print_stat_iteration_ilist : 
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-stat_iteration">stat_iteration</a>, <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_stat"><a href="#val-print_stat" class="anchor"></a><code><span><span class="keyword">val</span> print_stat : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stat">stat</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Prints statistics</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_output"><a href="#val-print_output" class="anchor"></a><code><span><span class="keyword">val</span> print_output : 
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-output">output</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Prints statistics</p><p>Prints the result of an analysis.</p></div></div><h3 id="internal-datatypes"><a href="#internal-datatypes" class="anchor"></a>Internal datatypes</h3><div class="odoc-spec"><div class="spec type anchored" id="type-attr"><a href="#type-attr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'abstract attr</span></span><span> = </span><span>{</span></code><ol><li id="type-attr.reach" class="def record field anchored"><a href="#type-attr.reach" class="anchor"></a><code><span><span class="keyword">mutable</span> reach : <span class="type-var">'abstract</span>;</span></code></li><li id="type-attr.diff" class="def record field anchored"><a href="#type-attr.diff" class="anchor"></a><code><span><span class="keyword">mutable</span> diff : <span class="type-var">'abstract</span>;</span></code></li><li id="type-attr.empty" class="def record field anchored"><a href="#type-attr.empty" class="anchor"></a><code><span><span class="keyword">mutable</span> empty : bool;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-arc"><a href="#type-arc" class="anchor"></a><code><span><span class="keyword">type</span> <span>'arc arc</span></span><span> = </span><span>{</span></code><ol><li id="type-arc.arc" class="def record field anchored"><a href="#type-arc.arc" class="anchor"></a><code><span><span class="keyword">mutable</span> arc : <span class="type-var">'arc</span>;</span></code></li><li id="type-arc.aempty" class="def record field anchored"><a href="#type-arc.aempty" class="anchor"></a><code><span><span class="keyword">mutable</span> aempty : bool;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-infodyn"><a href="#type-infodyn" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) infodyn</span></span><span> = </span><span>{</span></code><ol><li id="type-infodyn.iaddhedge" class="def record field anchored"><a href="#type-infodyn.iaddhedge" class="anchor"></a><code><span><span class="keyword">mutable</span> iaddhedge : <span><span>(<span class="type-var">'hedge</span>, <span><span class="type-var">'vertex</span> array</span> * <span class="type-var">'vertex</span>)</span> <span class="xref-unresolved">Camllib</span>.PHashhe.t</span>;</span></code></li><li id="type-infodyn.iequation" class="def record field anchored"><a href="#type-infodyn.iequation" class="anchor"></a><code><span>iequation : <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-equation">equation</a></span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-info"><a href="#type-info" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) info</span></span><span> = </span><span>{</span></code><ol><li id="type-info.iinit" class="def record field anchored"><a href="#type-info.iinit" class="anchor"></a><code><span>iinit : <span><span class="type-var">'vertex</span> <span class="xref-unresolved">Camllib</span>.PSette.t</span>;</span></code></li><li id="type-info.itime" class="def record field anchored"><a href="#type-info.itime" class="anchor"></a><code><span>itime : <span>float <span class="xref-unresolved">Stdlib</span>.ref</span>;</span></code></li><li id="type-info.iascending" class="def record field anchored"><a href="#type-info.iascending" class="anchor"></a><code><span><span class="keyword">mutable</span> iascending : <span><span>(<a href="#type-stat_iteration">stat_iteration</a>, unit)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span>;</span></code></li><li id="type-info.idescending" class="def record field anchored"><a href="#type-info.idescending" class="anchor"></a><code><span><span class="keyword">mutable</span> idescending : <span><span>(<a href="#type-stat_iteration">stat_iteration</a>, unit)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span>;</span></code></li><li id="type-info.iworkvertex" class="def record field anchored"><a href="#type-info.iworkvertex" class="anchor"></a><code><span><span class="keyword">mutable</span> iworkvertex : <span><span>(<span class="type-var">'vertex</span>, unit)</span> <span class="xref-unresolved">Camllib</span>.PHashhe.t</span>;</span></code></li><li id="type-info.iworkhedge" class="def record field anchored"><a href="#type-info.iworkhedge" class="anchor"></a><code><span><span class="keyword">mutable</span> iworkhedge : <span><span>(<span class="type-var">'hedge</span>, unit)</span> <span class="xref-unresolved">Camllib</span>.PHashhe.t</span>;</span></code></li><li id="type-info.iinfodyn" class="def record field anchored"><a href="#type-info.iinfodyn" class="anchor"></a><code><span>iinfodyn : <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-infodyn">infodyn</a></span> option</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-graph"><a href="#type-graph" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge, 'abstract, 'arc) graph</span></span><span> =
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span><span class="type-var">'abstract</span> <a href="#type-attr">attr</a></span>, <span><span class="type-var">'arc</span> <a href="#type-arc">arc</a></span>, <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-info">info</a></span>)</span>
    <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_attr"><a href="#val-print_attr" class="anchor"></a><code><span><span class="keyword">val</span> print_attr : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-attr">attr</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_arc"><a href="#val-print_arc" class="anchor"></a><code><span><span class="keyword">val</span> print_arc : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-arc">arc</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_info"><a href="#val-print_info" class="anchor"></a><code><span><span class="keyword">val</span> print_info : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-info">info</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_workingsets"><a href="#val-print_workingsets" class="anchor"></a><code><span><span class="keyword">val</span> print_workingsets : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-graph">graph</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_graph"><a href="#val-print_graph" class="anchor"></a><code><span><span class="keyword">val</span> print_graph : 
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-graph">graph</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Prints internal graph.</p></div></div><h3 id="dot-output"><a href="#dot-output" class="anchor"></a>DOT output</h3><div class="odoc-spec"><div class="spec value anchored" id="val-dot_graph"><a href="#val-dot_graph" class="anchor"></a><code><span><span class="keyword">val</span> dot_graph : 
  <span><span class="optlabel">?style</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?titlestyle</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?vertexstyle</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?hedgestyle</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?strategy</span>:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-strategy">strategy</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?vertex</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-graph">graph</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">title</span>:string <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Prints internal graph on the (optional) formatter <code>man.dot_fmt</code>, see type <a href="#type-manager"><code>manager</code></a>.</p></div></div></div></body></html>
