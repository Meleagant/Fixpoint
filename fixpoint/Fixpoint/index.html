<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fixpoint (fixpoint.Fixpoint)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">fixpoint</a> &#x00BB; Fixpoint</nav><header class="odoc-preamble"><h1>Module <code><span>Fixpoint</span></code></h1><p>Fixpoint analysis of an equation system</p></header><nav class="odoc-toc"><ul><li><a href="#datatypes">Datatypes</a><ul><li><a href="#manager">Manager</a></li><li><a href="#static-equation-system">Static equation system</a></li><li><a href="#dynamically-explored-equation-system">Dynamically explored equation system</a></li><li><a href="#iteration-strategies">Iteration strategies</a></li><li><a href="#output">Output</a></li></ul></li><li><a href="#functions">Functions</a></li><li><a href="#printing-functions">Printing Functions</a></li></ul></nav><div class="odoc-content"><h3 id="datatypes"><a href="#datatypes" class="anchor"></a>Datatypes</h3><h4 id="manager"><a href="#manager" class="anchor"></a>Manager</h4><p>The manager parameterizes the fixpoint solver with the following types:</p><ul><li><code>'vertex</code>: type of vertex/variable (identifier) in the hypergraph describing the equation system;</li><li><code>'hedge</code>: type of hyperedge/function (identifier) in the hypergraph describing the equation system;</li><li><code>'abstract</code>: type of abstract values associated to vertices/variables;</li><li><code>'arc</code>: type of information associated to hyperedges/functions;</li></ul><p>and values:</p><ul><li>Lattice operations on abstract values; the argument of type <code>'vertex</code> indicates to which vertex the result of the function is associated (useful when abstract values are typed by an environment, for instance)</li><li>Functions to initialize variables and to interpret hyperedges/functions;</li><li>Printing functions for type parameters;</li><li>Options, mainly about widening;</li><li>Debugging options, for text (and possibly DOT) output on the formatter <code>print_fmt</code>;</li><li>Printing functions for DOT output on the optional formatter <code>dot_fmt</code>.</li></ul><div class="odoc-spec"><div class="spec type anchored" id="type-manager"><a href="#type-manager" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge, 'abstract, 'arc) manager</span></span><span> =
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'abstract</span>, <span class="type-var">'arc</span>)</span> <a href="../FixpointType/index.html#type-manager">FixpointType.manager</a></span></span><span> =
  </span><span>{</span></code><ol><li id="type-manager.bottom" class="def record field anchored"><a href="#type-manager.bottom" class="anchor"></a><code><span><span class="keyword">mutable</span> bottom : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Create a bottom value</p><span class="comment-delim">*)</span></div></li><li id="type-manager.canonical" class="def record field anchored"><a href="#type-manager.canonical" class="anchor"></a><code><span><span class="keyword">mutable</span> canonical : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Make an abstract value canonical</p><span class="comment-delim">*)</span></div></li><li id="type-manager.is_bottom" class="def record field anchored"><a href="#type-manager.is_bottom" class="anchor"></a><code><span><span class="keyword">mutable</span> is_bottom : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Emptiness test</p><span class="comment-delim">*)</span></div></li><li id="type-manager.is_leq" class="def record field anchored"><a href="#type-manager.is_leq" class="anchor"></a><code><span><span class="keyword">mutable</span> is_leq : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Inclusion test</p><span class="comment-delim">*)</span></div></li><li id="type-manager.join" class="def record field anchored"><a href="#type-manager.join" class="anchor"></a><code><span><span class="keyword">mutable</span> join : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code></li><li id="type-manager.join_list" class="def record field anchored"><a href="#type-manager.join_list" class="anchor"></a><code><span><span class="keyword">mutable</span> join_list : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'abstract</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binary and n-ary join operation</p><span class="comment-delim">*)</span></div></li><li id="type-manager.widening" class="def record field anchored"><a href="#type-manager.widening" class="anchor"></a><code><span><span class="keyword">mutable</span> widening : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Apply widening at the given point, with the two arguments. Widening will always be applied with first argument being included in the second one.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.odiff" class="def record field anchored"><a href="#type-manager.odiff" class="anchor"></a><code><span><span class="keyword">mutable</span> odiff : <span><span>(<span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>)</span> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Sound approximation of set difference (optional)</p><span class="comment-delim">*)</span></div></li><li id="type-manager.abstract_init" class="def record field anchored"><a href="#type-manager.abstract_init" class="anchor"></a><code><span><span class="keyword">mutable</span> abstract_init : <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return the non-bottom initial value associated to the given vertex</p><span class="comment-delim">*)</span></div></li><li id="type-manager.arc_init" class="def record field anchored"><a href="#type-manager.arc_init" class="anchor"></a><code><span><span class="keyword">mutable</span> arc_init : <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'arc</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Initial value for arcs</p><span class="comment-delim">*)</span></div></li><li id="type-manager.apply" class="def record field anchored"><a href="#type-manager.apply" class="anchor"></a><code><span><span class="keyword">mutable</span> apply : <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'abstract</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'arc</span> * <span class="type-var">'abstract</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Apply the function indexed by <code>hedge</code> to the array of arguments.</p><p>It returns the new abstract value, but also a user-defined information that will be associated to the hyperedge in the result.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.print_vertex" class="def record field anchored"><a href="#type-manager.print_vertex" class="anchor"></a><code><span><span class="keyword">mutable</span> print_vertex : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-manager.print_hedge" class="def record field anchored"><a href="#type-manager.print_hedge" class="anchor"></a><code><span><span class="keyword">mutable</span> print_hedge : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-manager.print_abstract" class="def record field anchored"><a href="#type-manager.print_abstract" class="anchor"></a><code><span><span class="keyword">mutable</span> print_abstract : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'abstract</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-manager.print_arc" class="def record field anchored"><a href="#type-manager.print_arc" class="anchor"></a><code><span><span class="keyword">mutable</span> print_arc : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'arc</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Printing functions</p><span class="comment-delim">*)</span></div></li><li id="type-manager.accumulate" class="def record field anchored"><a href="#type-manager.accumulate" class="anchor"></a><code><span><span class="keyword">mutable</span> accumulate : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If true, during ascending phase, compute the union of old reachable value with growing incoming hyperedges. If false, recompute all incoming hyperedges.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.print_fmt" class="def record field anchored"><a href="#type-manager.print_fmt" class="anchor"></a><code><span><span class="keyword">mutable</span> print_fmt : <span class="xref-unresolved">Stdlib</span>.Format.formatter;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typically equal to <code>Format.std_formatter</code></p><span class="comment-delim">*)</span></div></li><li id="type-manager.print_analysis" class="def record field anchored"><a href="#type-manager.print_analysis" class="anchor"></a><code><span><span class="keyword">mutable</span> print_analysis : bool;</span></code></li><li id="type-manager.print_component" class="def record field anchored"><a href="#type-manager.print_component" class="anchor"></a><code><span><span class="keyword">mutable</span> print_component : bool;</span></code></li><li id="type-manager.print_step" class="def record field anchored"><a href="#type-manager.print_step" class="anchor"></a><code><span><span class="keyword">mutable</span> print_step : bool;</span></code></li><li id="type-manager.print_state" class="def record field anchored"><a href="#type-manager.print_state" class="anchor"></a><code><span><span class="keyword">mutable</span> print_state : bool;</span></code></li><li id="type-manager.print_postpre" class="def record field anchored"><a href="#type-manager.print_postpre" class="anchor"></a><code><span><span class="keyword">mutable</span> print_postpre : bool;</span></code></li><li id="type-manager.print_workingsets" class="def record field anchored"><a href="#type-manager.print_workingsets" class="anchor"></a><code><span><span class="keyword">mutable</span> print_workingsets : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Printing Options</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_fmt" class="def record field anchored"><a href="#type-manager.dot_fmt" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_fmt : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Some fmt</code> enables DOT output. You can set dummy values to the fields below if you always set <code>None</code> and you do not want DOT output.</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_vertex" class="def record field anchored"><a href="#type-manager.dot_vertex" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_vertex : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print vertex identifiers in DOT format</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_hedge" class="def record field anchored"><a href="#type-manager.dot_hedge" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_hedge : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print hyperedge identifiers in DOT format (vertices and hyperedges identifiers should be different, as they are represented by DOT vertices</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_attrvertex" class="def record field anchored"><a href="#type-manager.dot_attrvertex" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_attrvertex : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print the displayed information in boxes</p><span class="comment-delim">*)</span></div></li><li id="type-manager.dot_attrhedge" class="def record field anchored"><a href="#type-manager.dot_attrhedge" class="anchor"></a><code><span><span class="keyword">mutable</span> dot_attrhedge : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print the displayed information for hyperedges</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><h4 id="static-equation-system"><a href="#static-equation-system" class="anchor"></a>Static equation system</h4><p>A static equation system is defined by an hypergraph, of type <code>PSHGraph.t</code>, see <a href="#val-analysis_std"><code>analysis_std</code></a> and <a href="#val-analysis_guided"><code>analysis_guided</code></a></p><h4 id="dynamically-explored-equation-system"><a href="#dynamically-explored-equation-system" class="anchor"></a>Dynamically explored equation system</h4><div class="odoc-spec"><div class="spec type anchored" id="type-equation"><a href="#type-equation" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) equation</span></span><span> =
  <span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'hedge</span>, <span><span class="type-var">'vertex</span> array</span> * <span class="type-var">'vertex</span>)</span> <span class="xref-unresolved">Camllib</span>.PMappe.t</span></span></code></div><div class="spec-doc"><p>Function that explores dynamically an equation system. <code>equation vertex</code> returns a map hat associates to each successor hyperedge a pair of composed of the set of predecessor vertices, and the successor vertex.</p></div></div><h4 id="iteration-strategies"><a href="#iteration-strategies" class="anchor"></a>Iteration strategies</h4><div class="odoc-spec"><div class="spec type anchored" id="type-strategy_iteration"><a href="#type-strategy_iteration" class="anchor"></a><code><span><span class="keyword">type</span> strategy_iteration</span><span> = <a href="../FixpointType/index.html#type-strategy_iteration">FixpointType.strategy_iteration</a></span><span> = </span><span>{</span></code><ol><li id="type-strategy_iteration.widening_start" class="def record field anchored"><a href="#type-strategy_iteration.widening_start" class="anchor"></a><code><span><span class="keyword">mutable</span> widening_start : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Nb of initial steps without widening in the current strategy</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.widening_descend" class="def record field anchored"><a href="#type-strategy_iteration.widening_descend" class="anchor"></a><code><span><span class="keyword">mutable</span> widening_descend : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Maximum nb. of descending steps in the current strategy</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.ascending_nb" class="def record field anchored"><a href="#type-strategy_iteration.ascending_nb" class="anchor"></a><code><span><span class="keyword">mutable</span> ascending_nb : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For stats</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.descending_nb" class="def record field anchored"><a href="#type-strategy_iteration.descending_nb" class="anchor"></a><code><span><span class="keyword">mutable</span> descending_nb : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For stats</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_iteration.descending_stable" class="def record field anchored"><a href="#type-strategy_iteration.descending_stable" class="anchor"></a><code><span><span class="keyword">mutable</span> descending_stable : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For stats</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Widening and Descending Options</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-strategy_vertex"><a href="#type-strategy_vertex" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) strategy_vertex</span></span><span> =
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="../FixpointType/index.html#type-strategy_vertex">FixpointType.strategy_vertex</a></span></span><span> =
  </span><span>{</span></code><ol><li id="type-strategy_vertex.vertex" class="def record field anchored"><a href="#type-strategy_vertex.vertex" class="anchor"></a><code><span><span class="keyword">mutable</span> vertex : <span class="type-var">'vertex</span>;</span></code></li><li id="type-strategy_vertex.hedges" class="def record field anchored"><a href="#type-strategy_vertex.hedges" class="anchor"></a><code><span><span class="keyword">mutable</span> hedges : <span><span class="type-var">'hedge</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Order in which the incoming hyperedges will be applied</p><span class="comment-delim">*)</span></div></li><li id="type-strategy_vertex.widen" class="def record field anchored"><a href="#type-strategy_vertex.widen" class="anchor"></a><code><span><span class="keyword">mutable</span> widen : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Should this vertex be a widening point ?</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Strategy to be applied for the vertex <code>vertex</code>.</p><ul><li><code>hedges</code> is a list of incoming hyperedges. The effect of hyperedges are applied &quot;in parallel&quot; and the destination vertex is updated. Be cautious: if an incoming hyperedge is forgotten in this list, it won't be taken into account in the analysis.</li><li><code>widen</code> specifies whether the vertex is a widening point or not.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-strategy"><a href="#type-strategy" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge) strategy</span></span><span> =
  <span><span>(<a href="#type-strategy_iteration">strategy_iteration</a>, <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-strategy_vertex">strategy_vertex</a></span>)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span></span></code></div><div class="spec-doc"><p>Type for defining iteration strategies. For instance, <code>[1; [2;3]; 4;
      [5]; 6]</code> means:</p><ul><li>update <code>1</code>;</li><li>update <code>2</code> then <code>3</code>, and loop until stabilization;</li><li>update <code>4</code>;</li><li>update <code>5</code> and loop until stabilization;</li><li>update <code>6</code> and ends the analysis.</li></ul><p>Moreover, to each (imbricated) list is associated a record of type <code>strategy_iteration</code>, which indicates when to start the widening, and the maximum number of descending iterations.</p><p>Some observations on this example:</p><ul><li>The user should specify correctly the strategy. Two vertices belonging to the same connex component should always belong to a loop. Here, if there is an edge from <code>6</code> to <code>2</code>, the loop will not be iterated.</li><li>A vertex may appear more than once in the strategy, if it is useful.</li><li>Definition of the set of widening point is independent from the order</li><li>of application, here. it is alos the user-responsability to ensure that</li><li>the computation will end.</li></ul><p>So-called stabilization loops can be recursive, like that: <code>[1; [2;
        [3;4]; [5]]; 6]</code>, where the loop <code>[3;4]</code> needs to be (temporarily stable) before going on with <code>5</code>.</p></div></div><h4 id="output"><a href="#output" class="anchor"></a>Output</h4><div class="odoc-spec"><div class="spec type anchored" id="type-stat_iteration"><a href="#type-stat_iteration" class="anchor"></a><code><span><span class="keyword">type</span> stat_iteration</span><span> = <a href="../FixpointType/index.html#type-stat_iteration">FixpointType.stat_iteration</a></span><span> = </span><span>{</span></code><ol><li id="type-stat_iteration.nb" class="def record field anchored"><a href="#type-stat_iteration.nb" class="anchor"></a><code><span><span class="keyword">mutable</span> nb : int;</span></code></li><li id="type-stat_iteration.stable" class="def record field anchored"><a href="#type-stat_iteration.stable" class="anchor"></a><code><span><span class="keyword">mutable</span> stable : bool;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stat"><a href="#type-stat" class="anchor"></a><code><span><span class="keyword">type</span> stat</span><span> = <a href="../FixpointType/index.html#type-stat">FixpointType.stat</a></span><span> = </span><span>{</span></code><ol><li id="type-stat.time" class="def record field anchored"><a href="#type-stat.time" class="anchor"></a><code><span><span class="keyword">mutable</span> time : float;</span></code></li><li id="type-stat.ascending" class="def record field anchored"><a href="#type-stat.ascending" class="anchor"></a><code><span><span class="keyword">mutable</span> ascending : <span><span>(<a href="#type-stat_iteration">stat_iteration</a>, unit)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span>;</span></code></li><li id="type-stat.descending" class="def record field anchored"><a href="#type-stat.descending" class="anchor"></a><code><span><span class="keyword">mutable</span> descending : <span><span>(<a href="#type-stat_iteration">stat_iteration</a>, unit)</span> <span class="xref-unresolved">Camllib</span>.Ilist.t</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>statistics at the end of the analysis</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-output"><a href="#type-output" class="anchor"></a><code><span><span class="keyword">type</span> <span>('vertex, 'hedge, 'abstract, 'arc) output</span></span><span> =
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'abstract</span>, <span class="type-var">'arc</span>, <a href="#type-stat">stat</a>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span></span></code></div><div class="spec-doc"><p>result of the analysis</p></div></div><h3 id="functions"><a href="#functions" class="anchor"></a>Functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-make_strategy_default"><a href="#val-make_strategy_default" class="anchor"></a><code><span><span class="keyword">val</span> make_strategy_default : 
  <span><span class="optlabel">?depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?widening_start</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?widening_descend</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?priority</span>:<span><span class="type-var">'hedge</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.priority</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">vertex_dummy</span>:<span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">hedge_dummy</span>:<span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'vertex</span> <span class="xref-unresolved">Camllib</span>.PSette.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-strategy">strategy</a></span></span></code></div><div class="spec-doc"><p>Build a &quot;default&quot; strategy, with the following options:</p><ul><li>depth: to apply the recursive strategy of Bourdoncle's paper. Default value is 2, which means that Strongly Connected Components are stabilized independently: the iteration order looks like <code>(1 2 (3 4 5)
       6 (7 8) 9)</code> where <code>1, 2, 6, 9</code> are SCC by themselves. A higher value defines a more recursive behavior, like <code>(1 2 (3 (4 5)) 6 (7 (8)) 9)</code>.</li></ul><ul><li>iteration: for each strategy, nb if initial steps without widening and max nb. of descending steps (the latter being used only for depth 2). Default is <code>(0,1)</code>.</li></ul><ul><li>priority: specify which hedges should be taken into account in the computation of the iteration order and the widening points (the one such that <code>priority h &gt;= 0</code> and the widening points, and also indicates which hyperedge should be explored first at a point of choice.</li></ul><p>One known usage for filtering: guided analysis, where one analyse a subgraph of the equation graph.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-analysis_std"><a href="#val-analysis_std" class="anchor"></a><code><span><span class="keyword">val</span> analysis_std : 
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'abstract</span>, <span class="type-var">'arc</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'vertex</span> <span class="xref-unresolved">Camllib</span>.PSette.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-strategy">strategy</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'abstract</span>, <span class="type-var">'arc</span>)</span> <a href="#type-output">output</a></span></span></code></div><div class="spec-doc"><p>Performs initialization, fixpoint analysis and descending, and measures the global analysis time.</p><p><code>analysis_std manager graph sinit strategy</code> takes a graph giving the structure of the equation system, a manager indicating how to interpret the equation system, a (super)set <code>sinit</code> of the variables to be initialized to a non-empty value, and an iteration strategy <code>strategy</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-analysis_guided"><a href="#val-analysis_guided" class="anchor"></a><code><span><span class="keyword">val</span> analysis_guided : 
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'vertex</span> <span class="xref-unresolved">Camllib</span>.PSette.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-strategy">strategy</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-output">output</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-analysis_std"><code>analysis_std</code></a>, but with the technique of Gopan and Reps published in Static Anlaysis Symposium, SAS'2007.</p><p><code>analysis_guided manager graph sinit make_strategy</code>: compared to <a href="#val-analysis_std"><code>analysis_std</code></a>, instead of providing a strategy, one provides a function <code>make_strategy</code> generating strategies, which takes as input a function filtering the edges to be considered. A typical value for the argument <code>make_strategy</code> is <code>(fun p -&gt;
        make_strategy_default ~priority:(PSHGraph.Filter p) vdummy
        hdummy graph sinit)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equation_of_graph"><a href="#val-equation_of_graph" class="anchor"></a><code><span><span class="keyword">val</span> equation_of_graph : 
  <span><span class="optlabel">?filter</span>:<span>(<span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-equation">equation</a></span></span></code></div><div class="spec-doc"><p>Generate from a graph a function of type <code>('vertex,
        'hedge) equation</code> or dynamically exploring the graph. The <code>filter</code> function allows to select a part of the graph.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-graph_of_equation"><a href="#val-graph_of_equation" class="anchor"></a><code><span><span class="keyword">val</span> graph_of_equation : 
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.compare</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?filter</span>:<span>(<span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">make_attrvertex</span>:<span>(<span><span class="type-var">'vertex</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'attr</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">make_attrhedge</span>:<span>(<span><span class="type-var">'hedge</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'arc</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">info</span>:<span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>)</span> <a href="#type-equation">equation</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'vertex</span> <span class="xref-unresolved">Camllib</span>.PSette.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Camllib</span>.PSHGraph.t</span></span></code></div><div class="spec-doc"><p>Generate from an equation a graph, using <code>make_attrvertex</code>, <code>make_attrhedge</code> and <code>info</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-analysis_dyn"><a href="#val-analysis_dyn" class="anchor"></a><code><span><span class="keyword">val</span> analysis_dyn : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Camllib</span>.SHGraph.compare</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">guided</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-equation">equation</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Camllib</span>.PSette.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="../FixpointType/index.html#type-graph">FixpointType.graph</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-strategy">strategy</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-output">output</a></span></span></code></div><div class="spec-doc"><p>Dynamic analysis.</p></div></div><h3 id="printing-functions"><a href="#printing-functions" class="anchor"></a>Printing Functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-print_strategy_vertex"><a href="#val-print_strategy_vertex" class="anchor"></a><code><span><span class="keyword">val</span> print_strategy_vertex : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-strategy_vertex">strategy_vertex</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>print_strategy_vertex man fmt sv</code> prints an object of type <code>strategy_vertex</code>, using the manager <code>man</code> for printing vertices and hyperedges. The output has the form <code>(boolean,vertex,[list of list of
      hedges])</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_strategy"><a href="#val-print_strategy" class="anchor"></a><code><span><span class="keyword">val</span> print_strategy : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-strategy">strategy</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>print_strategy_vertex man fmt sv</code> prints an object of type <code>strategy_vertex</code>, using the manager <code>man</code> for printing vertices and hyperedges. The output has the form <code>(boolean,vertex,[list of list of
      hedges])</code>.</p><p><code>print_strategy_vertex man fmt sv</code> prints an object of type <code>strategy</code>, using the manager <code>man</code> for printing vertices and hyperedges.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_stat"><a href="#val-print_stat" class="anchor"></a><code><span><span class="keyword">val</span> print_stat : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stat">stat</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>print_strategy_vertex man fmt sv</code> prints an object of type <code>strategy</code>, using the manager <code>man</code> for printing vertices and hyperedges.</p><p>Prints statistics</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_output"><a href="#val-print_output" class="anchor"></a><code><span><span class="keyword">val</span> print_output : 
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-manager">manager</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'vertex</span>, <span class="type-var">'hedge</span>, <span class="type-var">'attr</span>, <span class="type-var">'arc</span>)</span> <a href="#type-output">output</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Prints statistics</p><p>Prints the result of an analysis.</p></div></div></div></body></html>
